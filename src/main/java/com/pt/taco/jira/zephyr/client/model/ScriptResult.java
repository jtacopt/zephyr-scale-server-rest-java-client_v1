/*
 * Zephyr Scale Server API (v1)
 * ## DISCLAIMER  We strongly discourage and do not endorse using private APIs for any purpose. Important points to remember:  1. **Non-Endorsement**: We do not support or endorse private API usage.  2. **API Changes**: Private APIs may change without notice; use them at your own risk.  3. **Data Responsibility**: We are not responsible for issues arising from private API use, such ***as data corruption***.  Please follow our terms of service and official ***public*** APIs for a stable and secure application experience. Unauthorized private API use may lead to instability and ***data corruption***.  ## Accessing the API The Zephyr Scale REST API is ready to use if you have Zephyr Scale installed on your JIRA instance. All API uses the following base URL: ``` http://your-jira-host:port/your-jira-context/rest/atm/1.0/ ``` For instance, you can create test results using the \"testresult\" api: ``` POST http://localhost:2990/jira/rest/atm/1.0/testresult ```  ## Authentication Basics Any authentication that works with JIRA will work with the Zephyr Scale REST API. The prefered authentication methods are OAuth and HTTP Basic. See the [JIRA SERVER REST API](https://developer.atlassian.com/server/jira/platform/rest-apis) docs for details. ## Using Status and Environment Fields Some entities, such as the Test Results, may have status and environment fields. The values of these fields are identified by name, not by the localized name. Both fields may have custom values defined by the user on the Zephyr Scale configuration area. All values are **case sensitive**, and they must be set just as displayed on the add-on.  These are the default values, which must be used on the APIs instead of their localized versions: * Test Cases:   * Draft   * Approved   * Deprecated  * Test Runs:   * Not Executed   * In Progress   * Done  * Test Results:   * Not Executed   * In Progress   * Pass   * Fail   * Blocked ## Handling Date Format The API supports the ISO 8601 format for date/time fields. This allows you to pass in the level of detail you need to. When a field is not specified, the earliest possible value is the default. For example, if you do not specify a time of day, we will default to 00:00 (midnight). Similarly, not specifying a timezone defaults the timezone to GMT. The full representation is of the format: ``` yyyy-MM-ddTHH:mm:ss.SSSZ ``` This table illustrates some example valid dates and times:  | Input | Equivalent to | | ------ | ----------- | | 2016 | 2016-01-01T00:00:00.000Z | | 2016-04 | 2016-04-01T00:00:00.000Z | | 2016-04-15 | 2016-04-15T00:00:00.000Z | | 2016-04-15T16 | 2016-04-15T16:00:00.000Z | | 2016-04-15T16:15 | 2016-04-15T16:15:00.000Z | | 2016-04-15T16:15Z | 2016-04-15T16:15:00.000Z (GMT time zone) | | 2016-04-15T16:15-0300 | 2016-04-15T16:15:00.000-0300 (Brazil time zone) |
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.pt.taco.jira.zephyr.client.model;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.google.gson.annotations.SerializedName;
import lombok.NoArgsConstructor;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * ScriptResult
 */
@NoArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ScriptResult {
    public static final String SERIALIZED_NAME_TRACE_LINKS = "traceLinks";
    public static final String SERIALIZED_NAME_TEST_DATA = "testData";
    public static final String SERIALIZED_NAME_PARAMETER_SET_ID = "parameterSetId";
    public static final String SERIALIZED_NAME_STEP_ATTACHMENTS_MAPPING = "stepAttachmentsMapping";
    public static final String SERIALIZED_NAME_EXPECTED_RESULT = "expectedResult";
    public static final String SERIALIZED_NAME_EXECUTION_DATE = "executionDate";
    public static final String SERIALIZED_NAME_INDEX = "index";
    public static final String SERIALIZED_NAME_DESCRIPTION = "description";
    public static final String SERIALIZED_NAME_COMMENT = "comment";
    public static final String SERIALIZED_NAME_STATUS = "status";
    @SerializedName(SERIALIZED_NAME_TRACE_LINKS)
    private List<String> traceLinks;
    @SerializedName(SERIALIZED_NAME_TEST_DATA)
    private String testData;
    @SerializedName(SERIALIZED_NAME_PARAMETER_SET_ID)
    private Integer parameterSetId;
    @SerializedName(SERIALIZED_NAME_STEP_ATTACHMENTS_MAPPING)
    private String stepAttachmentsMapping;
    @SerializedName(SERIALIZED_NAME_EXPECTED_RESULT)
    private String expectedResult;
    @SerializedName(SERIALIZED_NAME_EXECUTION_DATE)
    private String executionDate;
    @SerializedName(SERIALIZED_NAME_INDEX)
    private Integer index;
    @SerializedName(SERIALIZED_NAME_DESCRIPTION)
    private String description;
    @SerializedName(SERIALIZED_NAME_COMMENT)
    private String comment;
    @SerializedName(SERIALIZED_NAME_STATUS)
    private String status;

    public ScriptResult traceLinks(List<String> traceLinks) {

        this.traceLinks = traceLinks;
        return this;
    }

    public ScriptResult addTraceLinksItem(String traceLinksItem) {
        if (this.traceLinks == null) {
            this.traceLinks = new ArrayList<>();
        }
        this.traceLinks.add(traceLinksItem);
        return this;
    }

    /**
     * Get traceLinks
     *
     * @return traceLinks
     **/
    @Nullable

    public List<String> getTraceLinks() {
        return traceLinks;
    }


    public void setTraceLinks(List<String> traceLinks) {
        this.traceLinks = traceLinks;
    }


    public ScriptResult testData(String testData) {

        this.testData = testData;
        return this;
    }

    /**
     * Get testData
     *
     * @return testData
     **/
    @Nullable

    public String getTestData() {
        return testData;
    }


    public void setTestData(String testData) {
        this.testData = testData;
    }


    public ScriptResult parameterSetId(Integer parameterSetId) {

        this.parameterSetId = parameterSetId;
        return this;
    }

    /**
     * Get parameterSetId
     *
     * @return parameterSetId
     **/
    @javax.annotation.Nullable

    public Integer getParameterSetId() {
        return parameterSetId;
    }


    public void setParameterSetId(Integer parameterSetId) {
        this.parameterSetId = parameterSetId;
    }


    public ScriptResult stepAttachmentsMapping(String stepAttachmentsMapping) {

        this.stepAttachmentsMapping = stepAttachmentsMapping;
        return this;
    }

    /**
     * Get stepAttachmentsMapping
     *
     * @return stepAttachmentsMapping
     **/
    @Nullable

    public String getStepAttachmentsMapping() {
        return stepAttachmentsMapping;
    }


    public void setStepAttachmentsMapping(String stepAttachmentsMapping) {
        this.stepAttachmentsMapping = stepAttachmentsMapping;
    }


    public ScriptResult expectedResult(String expectedResult) {

        this.expectedResult = expectedResult;
        return this;
    }

    /**
     * Get expectedResult
     *
     * @return expectedResult
     **/
    @Nullable

    public String getExpectedResult() {
        return expectedResult;
    }


    public void setExpectedResult(String expectedResult) {
        this.expectedResult = expectedResult;
    }


    public ScriptResult executionDate(String executionDate) {

        this.executionDate = executionDate;
        return this;
    }

    /**
     * Get executionDate
     *
     * @return executionDate
     **/
    @Nullable

    public String getExecutionDate() {
        return executionDate;
    }


    public void setExecutionDate(String executionDate) {
        this.executionDate = executionDate;
    }


    public ScriptResult index(Integer index) {

        this.index = index;
        return this;
    }

    /**
     * Get index
     *
     * @return index
     **/
    @Nullable

    public Integer getIndex() {
        return index;
    }


    public void setIndex(Integer index) {
        this.index = index;
    }


    public ScriptResult description(String description) {

        this.description = description;
        return this;
    }

    /**
     * Get description
     *
     * @return description
     **/
    @Nullable

    public String getDescription() {
        return description;
    }


    public void setDescription(String description) {
        this.description = description;
    }


    public ScriptResult comment(String comment) {

        this.comment = comment;
        return this;
    }

    /**
     * Get comment
     *
     * @return comment
     **/
    @Nullable

    public String getComment() {
        return comment;
    }


    public void setComment(String comment) {
        this.comment = comment;
    }


    public ScriptResult status(String status) {

        this.status = status;
        return this;
    }

    /**
     * Get status
     *
     * @return status
     **/
    @Nullable

    public String getStatus() {
        return status;
    }


    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ScriptResult scriptResult = (ScriptResult) o;
        return Objects.equals(this.traceLinks, scriptResult.traceLinks) &&
                Objects.equals(this.testData, scriptResult.testData) &&
                Objects.equals(this.parameterSetId, scriptResult.parameterSetId) &&
                Objects.equals(this.stepAttachmentsMapping, scriptResult.stepAttachmentsMapping) &&
                Objects.equals(this.expectedResult, scriptResult.expectedResult) &&
                Objects.equals(this.executionDate, scriptResult.executionDate) &&
                Objects.equals(this.index, scriptResult.index) &&
                Objects.equals(this.description, scriptResult.description) &&
                Objects.equals(this.comment, scriptResult.comment) &&
                Objects.equals(this.status, scriptResult.status);
    }

    @Override
    public int hashCode() {
        return Objects.hash(traceLinks, testData, parameterSetId, stepAttachmentsMapping, expectedResult, executionDate, index, description, comment, status);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class ScriptResult {\n");
        sb.append("    traceLinks: ").append(toIndentedString(traceLinks)).append("\n");
        sb.append("    testData: ").append(toIndentedString(testData)).append("\n");
        sb.append("    parameterSetId: ").append(toIndentedString(parameterSetId)).append("\n");
        sb.append("    stepAttachmentsMapping: ").append(toIndentedString(stepAttachmentsMapping)).append("\n");
        sb.append("    expectedResult: ").append(toIndentedString(expectedResult)).append("\n");
        sb.append("    executionDate: ").append(toIndentedString(executionDate)).append("\n");
        sb.append("    index: ").append(toIndentedString(index)).append("\n");
        sb.append("    description: ").append(toIndentedString(description)).append("\n");
        sb.append("    comment: ").append(toIndentedString(comment)).append("\n");
        sb.append("    status: ").append(toIndentedString(status)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n    ");
    }

}

