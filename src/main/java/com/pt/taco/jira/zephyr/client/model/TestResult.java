/*
 * Zephyr Scale Server API (v1)
 * ## DISCLAIMER  We strongly discourage and do not endorse using private APIs for any purpose. Important points to remember:  1. **Non-Endorsement**: We do not support or endorse private API usage.  2. **API Changes**: Private APIs may change without notice; use them at your own risk.  3. **Data Responsibility**: We are not responsible for issues arising from private API use, such ***as data corruption***.  Please follow our terms of service and official ***public*** APIs for a stable and secure application experience. Unauthorized private API use may lead to instability and ***data corruption***.  ## Accessing the API The Zephyr Scale REST API is ready to use if you have Zephyr Scale installed on your JIRA instance. All API uses the following base URL: ``` http://your-jira-host:port/your-jira-context/rest/atm/1.0/ ``` For instance, you can create test results using the \"testresult\" api: ``` POST http://localhost:2990/jira/rest/atm/1.0/testresult ```  ## Authentication Basics Any authentication that works with JIRA will work with the Zephyr Scale REST API. The prefered authentication methods are OAuth and HTTP Basic. See the [JIRA SERVER REST API](https://developer.atlassian.com/server/jira/platform/rest-apis) docs for details. ## Using Status and Environment Fields Some entities, such as the Test Results, may have status and environment fields. The values of these fields are identified by name, not by the localized name. Both fields may have custom values defined by the user on the Zephyr Scale configuration area. All values are **case sensitive**, and they must be set just as displayed on the add-on.  These are the default values, which must be used on the APIs instead of their localized versions: * Test Cases:   * Draft   * Approved   * Deprecated  * Test Runs:   * Not Executed   * In Progress   * Done  * Test Results:   * Not Executed   * In Progress   * Pass   * Fail   * Blocked ## Handling Date Format The API supports the ISO 8601 format for date/time fields. This allows you to pass in the level of detail you need to. When a field is not specified, the earliest possible value is the default. For example, if you do not specify a time of day, we will default to 00:00 (midnight). Similarly, not specifying a timezone defaults the timezone to GMT. The full representation is of the format: ``` yyyy-MM-ddTHH:mm:ss.SSSZ ``` This table illustrates some example valid dates and times:  | Input | Equivalent to | | ------ | ----------- | | 2016 | 2016-01-01T00:00:00.000Z | | 2016-04 | 2016-04-01T00:00:00.000Z | | 2016-04-15 | 2016-04-15T00:00:00.000Z | | 2016-04-15T16 | 2016-04-15T16:00:00.000Z | | 2016-04-15T16:15 | 2016-04-15T16:15:00.000Z | | 2016-04-15T16:15Z | 2016-04-15T16:15:00.000Z (GMT time zone) | | 2016-04-15T16:15-0300 | 2016-04-15T16:15:00.000-0300 (Brazil time zone) |
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.pt.taco.jira.zephyr.client.model;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.google.gson.annotations.SerializedName;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * TestResult
 */
@NoArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class TestResult {

    public static final String SERIALIZED_NAME_ESTIMATED_TIME = "estimatedTime";
    public static final String SERIALIZED_NAME_EXECUTED_BY = "executedBy";
    public static final String SERIALIZED_NAME_ACTUAL_END_DATE = "actualEndDate";
    public static final String SERIALIZED_NAME_TRACE_LINKS = "traceLinks";
    public static final String SERIALIZED_NAME_EXECUTION_DATE = "executionDate";
    public static final String SERIALIZED_NAME_SCRIPT_RESULTS = "scriptResults";
    public static final String SERIALIZED_NAME_ASSIGNED_TO = "assignedTo";
    public static final String SERIALIZED_NAME_USER_KEY = "userKey";
    public static final String SERIALIZED_NAME_EXECUTION_TIME = "executionTime";
    public static final String SERIALIZED_NAME_TEST_CASE_KEY = "testCaseKey";
    public static final String SERIALIZED_NAME_ENVIRONMENT = "environment";
    public static final String SERIALIZED_NAME_AUTOMATED = "automated";
    public static final String SERIALIZED_NAME_ACTUAL_START_DATE = "actualStartDate";
    public static final String SERIALIZED_NAME_COMMENT = "comment";
    public static final String SERIALIZED_NAME_ID = "id";
    public static final String SERIALIZED_NAME_PROJECT_KEY = "projectKey";
    public static final String SERIALIZED_NAME_PROJECT_ID = "projectId";
    public static final String SERIALIZED_NAME_KEY = "key";
    public static final String SERIALIZED_NAME_STATUS = "status";
    public static final String SERIALIZED_NAME_CUSTOM_FIELDS = "customFields";
    public static final String SERIALIZED_NAME_ATTACHMENTS = "attachments";
    @SerializedName(SERIALIZED_NAME_ESTIMATED_TIME)
    private BigDecimal estimatedTime;
    @SerializedName(SERIALIZED_NAME_EXECUTED_BY)
    private String executedBy;
    @SerializedName(SERIALIZED_NAME_ACTUAL_END_DATE)
    private String actualEndDate;
    @SerializedName(SERIALIZED_NAME_TRACE_LINKS)
    private List<String> traceLinks;
    @SerializedName(SERIALIZED_NAME_EXECUTION_DATE)
    private String executionDate;
    @SerializedName(SERIALIZED_NAME_SCRIPT_RESULTS)
    private List<ScriptResult> scriptResults;
    @SerializedName(SERIALIZED_NAME_ASSIGNED_TO)
    private String assignedTo;
    @SerializedName(SERIALIZED_NAME_USER_KEY)
    private String userKey;
    @SerializedName(SERIALIZED_NAME_EXECUTION_TIME)
    private Integer executionTime;
    @SerializedName(SERIALIZED_NAME_TEST_CASE_KEY)
    private String testCaseKey;
    @SerializedName(SERIALIZED_NAME_ENVIRONMENT)
    private String environment;
    @SerializedName(SERIALIZED_NAME_AUTOMATED)
    private Boolean automated;
    @SerializedName(SERIALIZED_NAME_ACTUAL_START_DATE)
    private String actualStartDate;
    @SerializedName(SERIALIZED_NAME_COMMENT)
    private String comment;
    @SerializedName(SERIALIZED_NAME_ID)
    private Integer id;
    @SerializedName(SERIALIZED_NAME_PROJECT_KEY)
    private String projectKey;
    @SerializedName(SERIALIZED_NAME_PROJECT_ID)
    private Integer projectId;
    @SerializedName(SERIALIZED_NAME_KEY)
    private String key;
    @SerializedName(SERIALIZED_NAME_STATUS)
    private String status;
    @SerializedName(SERIALIZED_NAME_CUSTOM_FIELDS)
    private Map<String, String> customFields = new HashMap<>();
    @JsonIgnore
    private List<Attachment> attachments;

    public TestResult estimatedTime(BigDecimal estimatedTime) {

        this.estimatedTime = estimatedTime;
        return this;
    }

    /**
     * Get estimatedTime
     *
     * @return estimatedTime
     **/
    @javax.annotation.Nullable

    public BigDecimal getEstimatedTime() {
        return estimatedTime;
    }


    public void setEstimatedTime(BigDecimal estimatedTime) {
        this.estimatedTime = estimatedTime;
    }


    public TestResult executedBy(String executedBy) {

        this.executedBy = executedBy;
        return this;
    }

    /**
     * Get executedBy
     *
     * @return executedBy
     **/
    @javax.annotation.Nullable

    public String getExecutedBy() {
        return executedBy;
    }


    public void setExecutedBy(String executedBy) {
        this.executedBy = executedBy;
    }


    public TestResult actualEndDate(String actualEndDate) {

        this.actualEndDate = actualEndDate;
        return this;
    }

    /**
     * Get actualEndDate
     *
     * @return actualEndDate
     **/
    @javax.annotation.Nullable

    public String getActualEndDate() {
        return actualEndDate;
    }


    public void setActualEndDate(String actualEndDate) {
        this.actualEndDate = actualEndDate;
    }


    public TestResult traceLinks(List<String> traceLinks) {

        this.traceLinks = traceLinks;
        return this;
    }

    public TestResult addTraceLinksItem(String traceLinksItem) {
        if (this.traceLinks == null) {
            this.traceLinks = new ArrayList<>();
        }
        this.traceLinks.add(traceLinksItem);
        return this;
    }

    /**
     * Get traceLinks
     *
     * @return traceLinks
     **/
    @javax.annotation.Nullable

    public List<String> getTraceLinks() {
        return traceLinks;
    }


    public void setTraceLinks(List<String> traceLinks) {
        this.traceLinks = traceLinks;
    }


    public TestResult executionDate(String executionDate) {

        this.executionDate = executionDate;
        return this;
    }

    /**
     * Get executionDate
     *
     * @return executionDate
     **/
    @javax.annotation.Nullable

    public String getExecutionDate() {
        return executionDate;
    }


    public void setExecutionDate(String executionDate) {
        this.executionDate = executionDate;
    }


    public TestResult scriptResults(List<ScriptResult> scriptResults) {

        this.scriptResults = scriptResults;
        return this;
    }

    public TestResult addScriptResultsItem(ScriptResult scriptResultsItem) {
        if (this.scriptResults == null) {
            this.scriptResults = new ArrayList<>();
        }
        this.scriptResults.add(scriptResultsItem);
        return this;
    }

    /**
     * Get scriptResults
     *
     * @return scriptResults
     **/
    @javax.annotation.Nullable

    public List<ScriptResult> getScriptResults() {
        return scriptResults;
    }


    public void setScriptResults(List<ScriptResult> scriptResults) {
        this.scriptResults = scriptResults;
    }


    public TestResult assignedTo(String assignedTo) {

        this.assignedTo = assignedTo;
        return this;
    }

    /**
     * Get assignedTo
     *
     * @return assignedTo
     **/
    @javax.annotation.Nullable

    public String getAssignedTo() {
        return assignedTo;
    }


    public void setAssignedTo(String assignedTo) {
        this.assignedTo = assignedTo;
    }


    public TestResult userKey(String userKey) {

        this.userKey = userKey;
        return this;
    }

    /**
     * Get userKey
     *
     * @return userKey
     **/
    @javax.annotation.Nullable

    public String getUserKey() {
        return userKey;
    }


    public void setUserKey(String userKey) {
        this.userKey = userKey;
    }


    public TestResult executionTime(Integer executionTime) {

        this.executionTime = executionTime;
        return this;
    }

    /**
     * Get executionTime
     *
     * @return executionTime
     **/
    @javax.annotation.Nullable

    public Integer getExecutionTime() {
        return executionTime;
    }


    public void setExecutionTime(Integer executionTime) {
        this.executionTime = executionTime;
    }


    public TestResult testCaseKey(String testCaseKey) {

        this.testCaseKey = testCaseKey;
        return this;
    }

    /**
     * Get testCaseKey
     *
     * @return testCaseKey
     **/
    @javax.annotation.Nullable

    public String getTestCaseKey() {
        return testCaseKey;
    }


    public void setTestCaseKey(String testCaseKey) {
        this.testCaseKey = testCaseKey;
    }


    public TestResult environment(String environment) {

        this.environment = environment;
        return this;
    }

    /**
     * Get environment
     *
     * @return environment
     **/
    @javax.annotation.Nullable

    public String getEnvironment() {
        return environment;
    }


    public void setEnvironment(String environment) {
        this.environment = environment;
    }


    public TestResult automated(Boolean automated) {

        this.automated = automated;
        return this;
    }

    /**
     * Get automated
     *
     * @return automated
     **/
    @javax.annotation.Nullable

    public Boolean isAutomated() {
        return automated;
    }


    public void setAutomated(Boolean automated) {
        this.automated = automated;
    }


    public TestResult actualStartDate(String actualStartDate) {

        this.actualStartDate = actualStartDate;
        return this;
    }

    /**
     * Get actualStartDate
     *
     * @return actualStartDate
     **/
    @javax.annotation.Nullable

    public String getActualStartDate() {
        return actualStartDate;
    }


    public void setActualStartDate(String actualStartDate) {
        this.actualStartDate = actualStartDate;
    }


    public TestResult comment(String comment) {

        this.comment = comment;
        return this;
    }

    /**
     * Get comment
     *
     * @return comment
     **/
    @javax.annotation.Nullable

    public String getComment() {
        return comment;
    }


    public void setComment(String comment) {
        this.comment = comment;
    }


    public TestResult id(Integer id) {

        this.id = id;
        return this;
    }

    /**
     * Get id
     *
     * @return id
     **/
    public Integer getId() {
        return id;
    }


    public void setId(Integer id) {
        this.id = id;
    }


    public TestResult projectKey(String projectKey) {

        this.projectKey = projectKey;
        return this;
    }

    /**
     * Get projectKey
     *
     * @return projectKey
     **/
    @javax.annotation.Nullable

    public String getProjectKey() {
        return projectKey;
    }


    public void setProjectKey(String projectKey) {
        this.projectKey = projectKey;
    }


    public TestResult projectId(Integer projectId) {

        this.projectId = projectId;
        return this;
    }

    /**
     * Get projectId
     *
     * @return projectId
     **/
    @javax.annotation.Nullable

    public Integer getProjectId() {
        return projectId;
    }


    public void setProjectId(Integer projectId) {
        this.projectId = projectId;
    }


    public TestResult key(String key) {

        this.key = key;
        return this;
    }

    /**
     * Get key
     *
     * @return key
     **/
    @javax.annotation.Nullable

    public String getKey() {
        return key;
    }


    public void setKey(String key) {
        this.key = key;
    }


    public TestResult status(String status) {

        this.status = status;
        return this;
    }

    /**
     * Get status
     *
     * @return status
     **/
    @javax.annotation.Nullable

    public String getStatus() {
        return status;
    }


    public void setStatus(String status) {
        this.status = status;
    }


    public TestResult customFields(Map<String, String> customFields) {

        this.customFields = customFields;
        return this;
    }

    public TestResult putCustomFieldsItem(String key, String customFieldsItem) {
        if (this.customFields == null) {
            this.customFields = new HashMap<>();
        }
        this.customFields.put(key, customFieldsItem);
        return this;
    }

    /**
     * Get customFields
     *
     * @return customFields
     **/
    @javax.annotation.Nullable

    public Map<String, String> getCustomFields() {
        return customFields;
    }


    public void setCustomFields(Map<String, String> customFields) {
        this.customFields = customFields;
    }


    public TestResult attachments(List<Attachment> attachments) {

        this.attachments = attachments;
        return this;
    }

    public TestResult addAttachmentsItem(Attachment attachmentsItem) {
        if (this.attachments == null) {
            this.attachments = new ArrayList<>();
        }
        this.attachments.add(attachmentsItem);
        return this;
    }

    /**
     * Get attachments
     *
     * @return attachments
     **/
    @javax.annotation.Nullable

    public List<Attachment> getAttachments() {
        return attachments;
    }


    public void setAttachments(List<Attachment> attachments) {
        this.attachments = attachments;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        TestResult testResult = (TestResult) o;
        return Objects.equals(this.estimatedTime, testResult.estimatedTime) &&
                Objects.equals(this.executedBy, testResult.executedBy) &&
                Objects.equals(this.actualEndDate, testResult.actualEndDate) &&
                Objects.equals(this.traceLinks, testResult.traceLinks) &&
                Objects.equals(this.executionDate, testResult.executionDate) &&
                Objects.equals(this.scriptResults, testResult.scriptResults) &&
                Objects.equals(this.assignedTo, testResult.assignedTo) &&
                Objects.equals(this.userKey, testResult.userKey) &&
                Objects.equals(this.executionTime, testResult.executionTime) &&
                Objects.equals(this.testCaseKey, testResult.testCaseKey) &&
                Objects.equals(this.environment, testResult.environment) &&
                Objects.equals(this.automated, testResult.automated) &&
                Objects.equals(this.actualStartDate, testResult.actualStartDate) &&
                Objects.equals(this.comment, testResult.comment) &&
                Objects.equals(this.id, testResult.id) &&
                Objects.equals(this.projectKey, testResult.projectKey) &&
                Objects.equals(this.projectId, testResult.projectId) &&
                Objects.equals(this.key, testResult.key) &&
                Objects.equals(this.status, testResult.status) &&
                Objects.equals(this.customFields, testResult.customFields) &&
                Objects.equals(this.attachments, testResult.attachments);
    }

    @Override
    public int hashCode() {
        return Objects.hash(estimatedTime, executedBy, actualEndDate, traceLinks, executionDate, scriptResults, assignedTo, userKey, executionTime, testCaseKey, environment, automated, actualStartDate, comment, id, projectKey, projectId, key, status, customFields, attachments);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class TestResult {\n");
        sb.append("    estimatedTime: ").append(toIndentedString(estimatedTime)).append("\n");
        sb.append("    executedBy: ").append(toIndentedString(executedBy)).append("\n");
        sb.append("    actualEndDate: ").append(toIndentedString(actualEndDate)).append("\n");
        sb.append("    traceLinks: ").append(toIndentedString(traceLinks)).append("\n");
        sb.append("    executionDate: ").append(toIndentedString(executionDate)).append("\n");
        sb.append("    scriptResults: ").append(toIndentedString(scriptResults)).append("\n");
        sb.append("    assignedTo: ").append(toIndentedString(assignedTo)).append("\n");
        sb.append("    userKey: ").append(toIndentedString(userKey)).append("\n");
        sb.append("    executionTime: ").append(toIndentedString(executionTime)).append("\n");
        sb.append("    testCaseKey: ").append(toIndentedString(testCaseKey)).append("\n");
        sb.append("    environment: ").append(toIndentedString(environment)).append("\n");
        sb.append("    automated: ").append(toIndentedString(automated)).append("\n");
        sb.append("    actualStartDate: ").append(toIndentedString(actualStartDate)).append("\n");
        sb.append("    comment: ").append(toIndentedString(comment)).append("\n");
        sb.append("    id: ").append(toIndentedString(id)).append("\n");
        sb.append("    projectKey: ").append(toIndentedString(projectKey)).append("\n");
        sb.append("    projectId: ").append(toIndentedString(projectId)).append("\n");
        sb.append("    key: ").append(toIndentedString(key)).append("\n");
        sb.append("    status: ").append(toIndentedString(status)).append("\n");
        sb.append("    customFields: ").append(toIndentedString(customFields)).append("\n");
        sb.append("    attachments: ").append(toIndentedString(attachments)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n    ");
    }

}

