/*
 * Zephyr Scale Server API (v1)
 * ## DISCLAIMER  We strongly discourage and do not endorse using private APIs for any purpose. Important points to remember:  1. **Non-Endorsement**: We do not support or endorse private API usage.  2. **API Changes**: Private APIs may change without notice; use them at your own risk.  3. **Data Responsibility**: We are not responsible for issues arising from private API use, such ***as data corruption***.  Please follow our terms of service and official ***public*** APIs for a stable and secure application experience. Unauthorized private API use may lead to instability and ***data corruption***.  ## Accessing the API The Zephyr Scale REST API is ready to use if you have Zephyr Scale installed on your JIRA instance. All API uses the following base URL: ``` http://your-jira-host:port/your-jira-context/rest/atm/1.0/ ``` For instance, you can create test results using the \"testresult\" api: ``` POST http://localhost:2990/jira/rest/atm/1.0/testresult ```  ## Authentication Basics Any authentication that works with JIRA will work with the Zephyr Scale REST API. The prefered authentication methods are OAuth and HTTP Basic. See the [JIRA SERVER REST API](https://developer.atlassian.com/server/jira/platform/rest-apis) docs for details. ## Using Status and Environment Fields Some entities, such as the Test Results, may have status and environment fields. The values of these fields are identified by name, not by the localized name. Both fields may have custom values defined by the user on the Zephyr Scale configuration area. All values are **case sensitive**, and they must be set just as displayed on the add-on.  These are the default values, which must be used on the APIs instead of their localized versions: * Test Cases:   * Draft   * Approved   * Deprecated  * Test Runs:   * Not Executed   * In Progress   * Done  * Test Results:   * Not Executed   * In Progress   * Pass   * Fail   * Blocked ## Handling Date Format The API supports the ISO 8601 format for date/time fields. This allows you to pass in the level of detail you need to. When a field is not specified, the earliest possible value is the default. For example, if you do not specify a time of day, we will default to 00:00 (midnight). Similarly, not specifying a timezone defaults the timezone to GMT. The full representation is of the format: ``` yyyy-MM-ddTHH:mm:ss.SSSZ ``` This table illustrates some example valid dates and times:  | Input | Equivalent to | | ------ | ----------- | | 2016 | 2016-01-01T00:00:00.000Z | | 2016-04 | 2016-04-01T00:00:00.000Z | | 2016-04-15 | 2016-04-15T00:00:00.000Z | | 2016-04-15T16 | 2016-04-15T16:00:00.000Z | | 2016-04-15T16:15 | 2016-04-15T16:15:00.000Z | | 2016-04-15T16:15Z | 2016-04-15T16:15:00.000Z (GMT time zone) | | 2016-04-15T16:15-0300 | 2016-04-15T16:15:00.000-0300 (Brazil time zone) |
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.pt.taco.jira.zephyr.client;

import com.google.gson.reflect.TypeToken;
import com.pt.taco.jira.zephyr.client.model.Attachment;
import com.pt.taco.jira.zephyr.client.model.TestCase;
import com.pt.taco.jira.zephyr.client.model.TestResult;
import io.restassured.RestAssured;
import io.restassured.builder.RequestSpecBuilder;
import io.restassured.builder.ResponseSpecBuilder;
import io.restassured.http.ContentType;
import io.restassured.http.Method;
import io.restassured.response.Response;

import java.lang.reflect.Type;
import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

import static io.restassured.http.Method.DELETE;
import static io.restassured.http.Method.GET;
import static io.restassured.http.Method.POST;
import static io.restassured.http.Method.PUT;

public class TestCasesApi {

    private Supplier<RequestSpecBuilder> reqSpecSupplier;
    private Consumer<RequestSpecBuilder> reqSpecCustomizer;

    private TestCasesApi(Supplier<RequestSpecBuilder> reqSpecSupplier) {
        this.reqSpecSupplier = reqSpecSupplier;
    }

    public static TestCasesApi testCases(Supplier<RequestSpecBuilder> reqSpecSupplier) {
        return new TestCasesApi(reqSpecSupplier);
    }

    private RequestSpecBuilder createReqSpec() {
        RequestSpecBuilder reqSpec = reqSpecSupplier.get();
        if (reqSpecCustomizer != null) {
            reqSpecCustomizer.accept(reqSpec);
        }
        return reqSpec;
    }

    public List<Oper> getAllOperations() {
        return Arrays.asList(
                createTestCase(),
                createTestCaseAttachments(),
                createTestCaseStepAttachmentsByTestCaseKeyAndStepIndex(),
                deleteTestCaseByTestCaseKey(),
                findTestCase(),
                getAttachmentsFromStepByTestCaseKey(),
                getLastTestResultByTestCaseKey(),
                getTestCaseAttachments(),
                getTestCaseByTestCaseKey(),
                updateTestCaseByTestCaseKey()
        );
    }

    public CreateTestCaseOper createTestCase() {
        return new CreateTestCaseOper(createReqSpec());
    }

    public CreateTestCaseAttachmentsOper createTestCaseAttachments() {
        return new CreateTestCaseAttachmentsOper(createReqSpec());
    }

    public CreateTestCaseStepAttachmentsByTestCaseKeyAndStepIndexOper createTestCaseStepAttachmentsByTestCaseKeyAndStepIndex() {
        return new CreateTestCaseStepAttachmentsByTestCaseKeyAndStepIndexOper(createReqSpec());
    }

    public DeleteTestCaseByTestCaseKeyOper deleteTestCaseByTestCaseKey() {
        return new DeleteTestCaseByTestCaseKeyOper(createReqSpec());
    }

    public FindTestCaseOper findTestCase() {
        return new FindTestCaseOper(createReqSpec());
    }

    public GetAttachmentsFromStepByTestCaseKeyOper getAttachmentsFromStepByTestCaseKey() {
        return new GetAttachmentsFromStepByTestCaseKeyOper(createReqSpec());
    }

    public GetLastTestResultByTestCaseKeyOper getLastTestResultByTestCaseKey() {
        return new GetLastTestResultByTestCaseKeyOper(createReqSpec());
    }

    public GetTestCaseAttachmentsOper getTestCaseAttachments() {
        return new GetTestCaseAttachmentsOper(createReqSpec());
    }

    public GetTestCaseByTestCaseKeyOper getTestCaseByTestCaseKey() {
        return new GetTestCaseByTestCaseKeyOper(createReqSpec());
    }

    public UpdateTestCaseByTestCaseKeyOper updateTestCaseByTestCaseKey() {
        return new UpdateTestCaseByTestCaseKeyOper(createReqSpec());
    }

    /**
     * Customize request specification
     *
     * @param reqSpecCustomizer consumer to modify the RequestSpecBuilder
     * @return api
     */
    public TestCasesApi reqSpec(Consumer<RequestSpecBuilder> reqSpecCustomizer) {
        this.reqSpecCustomizer = reqSpecCustomizer;
        return this;
    }

    /**
     * Creates a new Test Case.  Whitespace is not allowed for labels, and it will be replaced by an underscore character. The field &#x60;&#x60;&#x60;type&#x60;&#x60;&#x60; of Test Script can have the values &#x60;&#x60;&#x60;PLAIN_TEXT&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;STEP_BY_STEP&#x60;&#x60;&#x60; or &#x60;&#x60;&#x60;BDD&#x60;&#x60;&#x60;. The field &#x60;&#x60;&#x60;text&#x60;&#x60;&#x60; describes the content of the plain text or BDD test script; otherwise, the steps can be described as objects using the field &#x60;&#x60;&#x60;steps&#x60;&#x60;&#x60;. Call To Tests can be added to the steps list by using the field &#x60;&#x60;&#x60;testCaseKey&#x60;&#x60;&#x60; with a Test Case key as value. The optional field &#x60;&#x60;&#x60;folder&#x60;&#x60;&#x60;, if defined, must contain an existent folder name. No folder will be created. The fields &#x60;&#x60;&#x60;status&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;priority&#x60;&#x60;&#x60; will be set to default values if not defined. The optional field parameters has two attributes: variables and entries. For attribute variables, two types are allowed: FREE_TEXT and DATA_SET. If using DATA_SET, an extra field should be informed, having the name of the dataset. If the dataset doesn’t exist, it will be automatically created. Attribute entries must only have values matching the informed variables. If a value of a dataset doesn’t exist, it will be automatically created for that dataset. Check the examples below for more details.
     *
     * @see #body  (optional)
     * return Object
     */
    public static class CreateTestCaseOper implements Oper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/testcase";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public CreateTestCaseOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setContentType(ContentType.JSON);
            reqSpec.setAccept(ContentType.JSON);
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /testcase
         *
         * @param handler handler
         * @param <T>     type
         * @return type
         */
        @Override
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /testcase
         *
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>() {
            }.getType();
            return execute(handler).as(type);
        }

        /**
         * @param testCase (TestCase)  (optional)
         * @return operation
         */
        public CreateTestCaseOper body(TestCase testCase) {
            reqSpec.setBody(testCase);
            return this;
        }

        /**
         * Customize request specification
         *
         * @param reqSpecCustomizer consumer to modify the RequestSpecBuilder
         * @return operation
         */
        public CreateTestCaseOper reqSpec(Consumer<RequestSpecBuilder> reqSpecCustomizer) {
            reqSpecCustomizer.accept(reqSpec);
            return this;
        }

        /**
         * Customize response specification
         *
         * @param respSpecCustomizer consumer to modify the ResponseSpecBuilder
         * @return operation
         */
        public CreateTestCaseOper respSpec(Consumer<ResponseSpecBuilder> respSpecCustomizer) {
            respSpecCustomizer.accept(respSpec);
            return this;
        }
    }

    /**
     * Create a new attachment on the specified Test Case.
     *
     * @see #testCaseKeyPath The key of the Test Case. (required)
     * return Object
     */
    public static class CreateTestCaseAttachmentsOper implements Oper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/testcase/{testCaseKey}/attachments";
        public static final String TEST_CASE_KEY_PATH = "testCaseKey";
        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public CreateTestCaseAttachmentsOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setContentType("multipart/form-data");
            reqSpec.setAccept(ContentType.JSON);
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /testcase/{testCaseKey}/attachments
         *
         * @param handler handler
         * @param <T>     type
         * @return type
         */
        @Override
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /testcase/{testCaseKey}/attachments
         *
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>() {
            }.getType();
            return execute(handler).as(type);
        }

        /**
         * @param testCaseKey (String) The key of the Test Case. (required)
         * @return operation
         */
        public CreateTestCaseAttachmentsOper testCaseKeyPath(Object testCaseKey) {
            reqSpec.addPathParam(TEST_CASE_KEY_PATH, testCaseKey);
            return this;
        }

        /**
         * Customize request specification
         *
         * @param reqSpecCustomizer consumer to modify the RequestSpecBuilder
         * @return operation
         */
        public CreateTestCaseAttachmentsOper reqSpec(Consumer<RequestSpecBuilder> reqSpecCustomizer) {
            reqSpecCustomizer.accept(reqSpec);
            return this;
        }

        /**
         * Customize response specification
         *
         * @param respSpecCustomizer consumer to modify the ResponseSpecBuilder
         * @return operation
         */
        public CreateTestCaseAttachmentsOper respSpec(Consumer<ResponseSpecBuilder> respSpecCustomizer) {
            respSpecCustomizer.accept(respSpec);
            return this;
        }
    }

    /**
     * Create a new attachment on the specified Step of a Test Case.
     *
     * @see #stepIndexPath The index of the Test Case step. (required)
     * @see #testCaseKeyPath The key of the Test Case. (required)
     * return Object
     */
    public static class CreateTestCaseStepAttachmentsByTestCaseKeyAndStepIndexOper implements Oper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/testcase/{testCaseKey}/step/{stepIndex}/attachments";
        public static final String STEP_INDEX_PATH = "stepIndex";
        public static final String TEST_CASE_KEY_PATH = "testCaseKey";
        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public CreateTestCaseStepAttachmentsByTestCaseKeyAndStepIndexOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setContentType("multipart/form-data");
            reqSpec.setAccept(ContentType.JSON);
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /testcase/{testCaseKey}/step/{stepIndex}/attachments
         *
         * @param handler handler
         * @param <T>     type
         * @return type
         */
        @Override
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /testcase/{testCaseKey}/step/{stepIndex}/attachments
         *
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>() {
            }.getType();
            return execute(handler).as(type);
        }

        /**
         * @param stepIndex (Integer) The index of the Test Case step. (required)
         * @return operation
         */
        public CreateTestCaseStepAttachmentsByTestCaseKeyAndStepIndexOper stepIndexPath(Object stepIndex) {
            reqSpec.addPathParam(STEP_INDEX_PATH, stepIndex);
            return this;
        }

        /**
         * @param testCaseKey (String) The key of the Test Case. (required)
         * @return operation
         */
        public CreateTestCaseStepAttachmentsByTestCaseKeyAndStepIndexOper testCaseKeyPath(Object testCaseKey) {
            reqSpec.addPathParam(TEST_CASE_KEY_PATH, testCaseKey);
            return this;
        }

        /**
         * Customize request specification
         *
         * @param reqSpecCustomizer consumer to modify the RequestSpecBuilder
         * @return operation
         */
        public CreateTestCaseStepAttachmentsByTestCaseKeyAndStepIndexOper reqSpec(Consumer<RequestSpecBuilder> reqSpecCustomizer) {
            reqSpecCustomizer.accept(reqSpec);
            return this;
        }

        /**
         * Customize response specification
         *
         * @param respSpecCustomizer consumer to modify the ResponseSpecBuilder
         * @return operation
         */
        public CreateTestCaseStepAttachmentsByTestCaseKeyAndStepIndexOper respSpec(Consumer<ResponseSpecBuilder> respSpecCustomizer) {
            respSpecCustomizer.accept(respSpec);
            return this;
        }
    }

    /**
     * Delete the Test Case matching the given key.
     *
     * @see #testCaseKeyPath The key of the Test Case. (required)
     */
    public static class DeleteTestCaseByTestCaseKeyOper implements Oper {

        public static final Method REQ_METHOD = DELETE;
        public static final String REQ_URI = "/testcase/{testCaseKey}";
        public static final String TEST_CASE_KEY_PATH = "testCaseKey";
        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public DeleteTestCaseByTestCaseKeyOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept(ContentType.JSON);
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * DELETE /testcase/{testCaseKey}
         *
         * @param handler handler
         * @param <T>     type
         * @return type
         */
        @Override
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * @param testCaseKey (String) The key of the Test Case. (required)
         * @return operation
         */
        public DeleteTestCaseByTestCaseKeyOper testCaseKeyPath(Object testCaseKey) {
            reqSpec.addPathParam(TEST_CASE_KEY_PATH, testCaseKey);
            return this;
        }

        /**
         * Customize request specification
         *
         * @param reqSpecCustomizer consumer to modify the RequestSpecBuilder
         * @return operation
         */
        public DeleteTestCaseByTestCaseKeyOper reqSpec(Consumer<RequestSpecBuilder> reqSpecCustomizer) {
            reqSpecCustomizer.accept(reqSpec);
            return this;
        }

        /**
         * Customize response specification
         *
         * @param respSpecCustomizer consumer to modify the ResponseSpecBuilder
         * @return operation
         */
        public DeleteTestCaseByTestCaseKeyOper respSpec(Consumer<ResponseSpecBuilder> respSpecCustomizer) {
            respSpecCustomizer.accept(respSpec);
            return this;
        }
    }

    /**
     * Retrieve the Test Cases that matches the query passed as parameter.
     *
     * @see #fieldsQuery The fields of the Test Case to be included on the response. If not set, all fields will be returned. Inexistent fields will be ignored. (optional)
     * @see #queryQuery A query to filter Test Cases. The query syntax is similar to the JIRA JQL.  * Available fields: &#x60;&#x60;&#x60;projectKey&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;key&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;name&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;status&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;priority&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;component&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;folder&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;estimatedTime&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;labels&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;owner&#x60;&#x60;&#x60; and custom fields. When filtering by custom fields, the field name must be quoted. * Available operators: &#x60;&#x60;&#x60;&#x3D;&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;&gt;&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;&gt;&#x3D;&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;&lt;&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;&lt;&#x3D;&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;IN&#x60;&#x60;&#x60; * For Single and Multi Choice custom fields, operator \&quot;&#x3D;\&quot; is not supported, use \&quot;IN\&quot; instead * Available logical operators: &#x60;&#x60;&#x60;AND&#x60;&#x60;&#x60;  It is always a good idea considering using the &#x60;&#x60;&#x60;projectKey&#x60;&#x60;&#x60; field to match values that only belongs to that project, such as statuses, folders, etc.  Folders always have to start with a \&quot;/\&quot;, for instance: \&quot;/a folder\&quot;. The \&quot;/\&quot; matches the root, above all folders.  The query syntax is very strict. The use of whitespaces between fields, operators and logical operators is required, as well as the use of double quotes for string values.  Usage examples: * projectKey &#x3D; \&quot;JQA\&quot; AND status &#x3D; \&quot;Draft\&quot; AND priority &#x3D; \&quot;High\&quot; * projectKey &#x3D; \&quot;JQA\&quot; AND status IN (\&quot;Draft\&quot;, \&quot;Deprecated\&quot;) AND labels IN (\&quot;Functional\&quot;, \&quot;UI\&quot;) * projectKey &#x3D; \&quot;JQA\&quot; AND status IN (\&quot;Draft\&quot;, \&quot;Deprecated\&quot;) AND labels IN (\&quot;Functional\&quot;, \&quot;UI\&quot;) * projectKey &#x3D; \&quot;JQA\&quot; AND status &#x3D; \&quot;Draft\&quot; AND folder &#x3D; \&quot;/\&quot; * projectKey &#x3D; \&quot;JQA\&quot; AND folder &#x3D; \&quot;/folder with some test cases\&quot; * projectKey &#x3D; \&quot;JQA\&quot; AND folder &#x3D; \&quot;/folder with some test cases/child folder\&quot; * projectKey &#x3D; \&quot;JQA\&quot; AND folder IN (\&quot;/parent folder\&quot;, \&quot;/parent folder/child folder\&quot;) * projectKey &#x3D; \&quot;JQA\&quot; AND \&quot;My Custom Field\&quot; &#x3D; \&quot;Some value\&quot; * projectKey &#x3D; \&quot;JQA\&quot; AND \&quot;Single Choice Custom Field\&quot; IN (\&quot;Some value\&quot;) * projectKey &#x3D; \&quot;JQA\&quot; AND \&quot;Multi Choice Custom Field\&quot; IN (\&quot;Some value\&quot;, \&quot;Another value\&quot;) * projectKey &#x3D; \&quot;JQA\&quot; AND issueKeys IN (\&quot;JQA-5\&quot;, \&quot;JQA-4\&quot;) * key IN (\&quot;JQA-T50\&quot;, \&quot;JTQ-T90\&quot;) * key IN (\&quot;JQA-T50\&quot;, \&quot;JTQ-T90\&quot;) AND name &#x3D; \&quot;My Test Case Name\&quot;  (optional)
     * @see #startAtQuery An offset to use with the query. This can be useful when paginating results. (optional)
     * @see #maxResultsQuery The max result count, limiting the query results. If not provided, the default value of 200 will be used. (optional)
     * return Object
     */
    public static class FindTestCaseOper implements Oper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/testcase/search";
        public static final String FIELDS_QUERY = "fields";
        public static final String QUERY_QUERY = "query";
        public static final String START_AT_QUERY = "startAt";
        public static final String MAX_RESULTS_QUERY = "maxResults";
        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public FindTestCaseOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept(ContentType.JSON);
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /testcase/search
         *
         * @param handler handler
         * @param <T>     type
         * @return type
         */
        @Override
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /testcase/search
         *
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>() {
            }.getType();
            return execute(handler).as(type);
        }

        /**
         * @param fields (String) The fields of the Test Case to be included on the response. If not set, all fields will be returned. Inexistent fields will be ignored. (optional)
         * @return operation
         */
        public FindTestCaseOper fieldsQuery(Object... fields) {
            reqSpec.addQueryParam(FIELDS_QUERY, fields);
            return this;
        }

        /**
         * @param query (String) A query to filter Test Cases. The query syntax is similar to the JIRA JQL.  * Available fields: &#x60;&#x60;&#x60;projectKey&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;key&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;name&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;status&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;priority&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;component&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;folder&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;estimatedTime&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;labels&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;owner&#x60;&#x60;&#x60; and custom fields. When filtering by custom fields, the field name must be quoted. * Available operators: &#x60;&#x60;&#x60;&#x3D;&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;&gt;&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;&gt;&#x3D;&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;&lt;&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;&lt;&#x3D;&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;IN&#x60;&#x60;&#x60; * For Single and Multi Choice custom fields, operator \&quot;&#x3D;\&quot; is not supported, use \&quot;IN\&quot; instead * Available logical operators: &#x60;&#x60;&#x60;AND&#x60;&#x60;&#x60;  It is always a good idea considering using the &#x60;&#x60;&#x60;projectKey&#x60;&#x60;&#x60; field to match values that only belongs to that project, such as statuses, folders, etc.  Folders always have to start with a \&quot;/\&quot;, for instance: \&quot;/a folder\&quot;. The \&quot;/\&quot; matches the root, above all folders.  The query syntax is very strict. The use of whitespaces between fields, operators and logical operators is required, as well as the use of double quotes for string values.  Usage examples: * projectKey &#x3D; \&quot;JQA\&quot; AND status &#x3D; \&quot;Draft\&quot; AND priority &#x3D; \&quot;High\&quot; * projectKey &#x3D; \&quot;JQA\&quot; AND status IN (\&quot;Draft\&quot;, \&quot;Deprecated\&quot;) AND labels IN (\&quot;Functional\&quot;, \&quot;UI\&quot;) * projectKey &#x3D; \&quot;JQA\&quot; AND status IN (\&quot;Draft\&quot;, \&quot;Deprecated\&quot;) AND labels IN (\&quot;Functional\&quot;, \&quot;UI\&quot;) * projectKey &#x3D; \&quot;JQA\&quot; AND status &#x3D; \&quot;Draft\&quot; AND folder &#x3D; \&quot;/\&quot; * projectKey &#x3D; \&quot;JQA\&quot; AND folder &#x3D; \&quot;/folder with some test cases\&quot; * projectKey &#x3D; \&quot;JQA\&quot; AND folder &#x3D; \&quot;/folder with some test cases/child folder\&quot; * projectKey &#x3D; \&quot;JQA\&quot; AND folder IN (\&quot;/parent folder\&quot;, \&quot;/parent folder/child folder\&quot;) * projectKey &#x3D; \&quot;JQA\&quot; AND \&quot;My Custom Field\&quot; &#x3D; \&quot;Some value\&quot; * projectKey &#x3D; \&quot;JQA\&quot; AND \&quot;Single Choice Custom Field\&quot; IN (\&quot;Some value\&quot;) * projectKey &#x3D; \&quot;JQA\&quot; AND \&quot;Multi Choice Custom Field\&quot; IN (\&quot;Some value\&quot;, \&quot;Another value\&quot;) * projectKey &#x3D; \&quot;JQA\&quot; AND issueKeys IN (\&quot;JQA-5\&quot;, \&quot;JQA-4\&quot;) * key IN (\&quot;JQA-T50\&quot;, \&quot;JTQ-T90\&quot;) * key IN (\&quot;JQA-T50\&quot;, \&quot;JTQ-T90\&quot;) AND name &#x3D; \&quot;My Test Case Name\&quot;  (optional)
         * @return operation
         */
        public FindTestCaseOper queryQuery(Object... query) {
            reqSpec.addQueryParam(QUERY_QUERY, query);
            return this;
        }

        /**
         * @param startAt (Integer) An offset to use with the query. This can be useful when paginating results. (optional)
         * @return operation
         */
        public FindTestCaseOper startAtQuery(Object... startAt) {
            reqSpec.addQueryParam(START_AT_QUERY, startAt);
            return this;
        }

        /**
         * @param maxResults (Integer) The max result count, limiting the query results. If not provided, the default value of 200 will be used. (optional)
         * @return operation
         */
        public FindTestCaseOper maxResultsQuery(Object... maxResults) {
            reqSpec.addQueryParam(MAX_RESULTS_QUERY, maxResults);
            return this;
        }

        /**
         * Customize request specification
         *
         * @param reqSpecCustomizer consumer to modify the RequestSpecBuilder
         * @return operation
         */
        public FindTestCaseOper reqSpec(Consumer<RequestSpecBuilder> reqSpecCustomizer) {
            reqSpecCustomizer.accept(reqSpec);
            return this;
        }

        /**
         * Customize response specification
         *
         * @param respSpecCustomizer consumer to modify the ResponseSpecBuilder
         * @return operation
         */
        public FindTestCaseOper respSpec(Consumer<ResponseSpecBuilder> respSpecCustomizer) {
            respSpecCustomizer.accept(respSpec);
            return this;
        }
    }

    /**
     * Retrieve the attachments for a test case step
     *
     * @see #stepIndexPath The index of the Test Case step. (required)
     * @see #testCaseKeyPath The key of the Test Case. (required)
     * return List&lt;Attachment&gt;
     */
    public static class GetAttachmentsFromStepByTestCaseKeyOper implements Oper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/testcase/{testCaseKey}/step/{stepIndex}/attachments";
        public static final String STEP_INDEX_PATH = "stepIndex";
        public static final String TEST_CASE_KEY_PATH = "testCaseKey";
        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public GetAttachmentsFromStepByTestCaseKeyOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept(ContentType.JSON);
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /testcase/{testCaseKey}/step/{stepIndex}/attachments
         *
         * @param handler handler
         * @param <T>     type
         * @return type
         */
        @Override
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /testcase/{testCaseKey}/step/{stepIndex}/attachments
         *
         * @param handler handler
         * @return List&lt;Attachment&gt;
         */
        public List<Attachment> executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<List<Attachment>>() {
            }.getType();
            return execute(handler).as(type);
        }

        /**
         * @param stepIndex (Integer) The index of the Test Case step. (required)
         * @return operation
         */
        public GetAttachmentsFromStepByTestCaseKeyOper stepIndexPath(Object stepIndex) {
            reqSpec.addPathParam(STEP_INDEX_PATH, stepIndex);
            return this;
        }

        /**
         * @param testCaseKey (String) The key of the Test Case. (required)
         * @return operation
         */
        public GetAttachmentsFromStepByTestCaseKeyOper testCaseKeyPath(Object testCaseKey) {
            reqSpec.addPathParam(TEST_CASE_KEY_PATH, testCaseKey);
            return this;
        }

        /**
         * Customize request specification
         *
         * @param reqSpecCustomizer consumer to modify the RequestSpecBuilder
         * @return operation
         */
        public GetAttachmentsFromStepByTestCaseKeyOper reqSpec(Consumer<RequestSpecBuilder> reqSpecCustomizer) {
            reqSpecCustomizer.accept(reqSpec);
            return this;
        }

        /**
         * Customize response specification
         *
         * @param respSpecCustomizer consumer to modify the ResponseSpecBuilder
         * @return operation
         */
        public GetAttachmentsFromStepByTestCaseKeyOper respSpec(Consumer<ResponseSpecBuilder> respSpecCustomizer) {
            respSpecCustomizer.accept(respSpec);
            return this;
        }
    }

    /**
     * Retrieve the last test result for a given key
     *
     * @see #testCaseKeyPath The key of the Test Case. (required)
     * return TestResult
     */
    public static class GetLastTestResultByTestCaseKeyOper implements Oper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/testcase/{testCaseKey}/testresult/latest";
        public static final String TEST_CASE_KEY_PATH = "testCaseKey";
        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public GetLastTestResultByTestCaseKeyOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept(ContentType.JSON);
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /testcase/{testCaseKey}/testresult/latest
         *
         * @param handler handler
         * @param <T>     type
         * @return type
         */
        @Override
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /testcase/{testCaseKey}/testresult/latest
         *
         * @param handler handler
         * @return TestResult
         */
        public TestResult executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<TestResult>() {
            }.getType();
            return execute(handler).as(type);
        }

        /**
         * @param testCaseKey (String) The key of the Test Case. (required)
         * @return operation
         */
        public GetLastTestResultByTestCaseKeyOper testCaseKeyPath(Object testCaseKey) {
            reqSpec.addPathParam(TEST_CASE_KEY_PATH, testCaseKey);
            return this;
        }

        /**
         * Customize request specification
         *
         * @param reqSpecCustomizer consumer to modify the RequestSpecBuilder
         * @return operation
         */
        public GetLastTestResultByTestCaseKeyOper reqSpec(Consumer<RequestSpecBuilder> reqSpecCustomizer) {
            reqSpecCustomizer.accept(reqSpec);
            return this;
        }

        /**
         * Customize response specification
         *
         * @param respSpecCustomizer consumer to modify the ResponseSpecBuilder
         * @return operation
         */
        public GetLastTestResultByTestCaseKeyOper respSpec(Consumer<ResponseSpecBuilder> respSpecCustomizer) {
            respSpecCustomizer.accept(respSpec);
            return this;
        }
    }

    /**
     * Retrieve the Test Case Attachments matching the given key.
     *
     * @see #testCaseKeyPath The key of the Test Case. (required)
     * return List&lt;Attachment&gt;
     */
    public static class GetTestCaseAttachmentsOper implements Oper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/testcase/{testCaseKey}/attachments";
        public static final String TEST_CASE_KEY_PATH = "testCaseKey";
        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public GetTestCaseAttachmentsOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept(ContentType.JSON);
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /testcase/{testCaseKey}/attachments
         *
         * @param handler handler
         * @param <T>     type
         * @return type
         */
        @Override
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /testcase/{testCaseKey}/attachments
         *
         * @param handler handler
         * @return List&lt;Attachment&gt;
         */
        public List<Attachment> executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<List<Attachment>>() {
            }.getType();
            return execute(handler).as(type);
        }

        /**
         * @param testCaseKey (String) The key of the Test Case. (required)
         * @return operation
         */
        public GetTestCaseAttachmentsOper testCaseKeyPath(Object testCaseKey) {
            reqSpec.addPathParam(TEST_CASE_KEY_PATH, testCaseKey);
            return this;
        }

        /**
         * Customize request specification
         *
         * @param reqSpecCustomizer consumer to modify the RequestSpecBuilder
         * @return operation
         */
        public GetTestCaseAttachmentsOper reqSpec(Consumer<RequestSpecBuilder> reqSpecCustomizer) {
            reqSpecCustomizer.accept(reqSpec);
            return this;
        }

        /**
         * Customize response specification
         *
         * @param respSpecCustomizer consumer to modify the ResponseSpecBuilder
         * @return operation
         */
        public GetTestCaseAttachmentsOper respSpec(Consumer<ResponseSpecBuilder> respSpecCustomizer) {
            respSpecCustomizer.accept(respSpec);
            return this;
        }
    }

    /**
     * Retrieve the Test Case matching the given key.
     *
     * @see #testCaseKeyPath The key of the Test Case. (required)
     * @see #fieldsQuery The fields of the Test Case to be included on the response. If not set, all fields will be returned. Inexistent fields will be ignored. (optional)
     * return Object
     */
    public static class GetTestCaseByTestCaseKeyOper implements Oper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/testcase/{testCaseKey}";
        public static final String TEST_CASE_KEY_PATH = "testCaseKey";
        public static final String FIELDS_QUERY = "fields";
        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public GetTestCaseByTestCaseKeyOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept(ContentType.JSON);
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /testcase/{testCaseKey}
         *
         * @param handler handler
         * @param <T>     type
         * @return type
         */
        @Override
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /testcase/{testCaseKey}
         *
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>() {
            }.getType();
            return execute(handler).as(type);
        }

        /**
         * @param testCaseKey (String) The key of the Test Case. (required)
         * @return operation
         */
        public GetTestCaseByTestCaseKeyOper testCaseKeyPath(Object testCaseKey) {
            reqSpec.addPathParam(TEST_CASE_KEY_PATH, testCaseKey);
            return this;
        }

        /**
         * @param fields (String) The fields of the Test Case to be included on the response. If not set, all fields will be returned. Inexistent fields will be ignored. (optional)
         * @return operation
         */
        public GetTestCaseByTestCaseKeyOper fieldsQuery(Object... fields) {
            reqSpec.addQueryParam(FIELDS_QUERY, fields);
            return this;
        }

        /**
         * Customize request specification
         *
         * @param reqSpecCustomizer consumer to modify the RequestSpecBuilder
         * @return operation
         */
        public GetTestCaseByTestCaseKeyOper reqSpec(Consumer<RequestSpecBuilder> reqSpecCustomizer) {
            reqSpecCustomizer.accept(reqSpec);
            return this;
        }

        /**
         * Customize response specification
         *
         * @param respSpecCustomizer consumer to modify the ResponseSpecBuilder
         * @return operation
         */
        public GetTestCaseByTestCaseKeyOper respSpec(Consumer<ResponseSpecBuilder> respSpecCustomizer) {
            respSpecCustomizer.accept(respSpec);
            return this;
        }
    }

    /**
     * Updates a Test Case.  Whitespace is not allowed for labels, and it will be replaced by an underscore character. The field &#x60;&#x60;&#x60;type&#x60;&#x60;&#x60; of Test Script can have the values &#x60;&#x60;&#x60;PLAIN_TEXT&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;STEP_BY_STEP&#x60;&#x60;&#x60; or &#x60;&#x60;&#x60;BDD&#x60;&#x60;&#x60;. The field &#x60;&#x60;&#x60;text&#x60;&#x60;&#x60; describes the content of the plain text or BDD test script; otherwise, the steps can be described as objects using the field &#x60;&#x60;&#x60;steps&#x60;&#x60;&#x60;. The field &#x60;&#x60;&#x60;folder&#x60;&#x60;&#x60;, if defined, must contain an existent folder name. No folder will be created. Only fields present on the body will be updated. The field &#x60;&#x60;&#x60;projectKey&#x60;&#x60;&#x60; cannot be changed. Call To Tests can be added to the steps list by using the field &#x60;&#x60;&#x60;testCaseKey&#x60;&#x60;&#x60; with a Test Case key as value. The optional field parameters has two attributes: variables and entries. For attribute variables, two types are allowed: FREE_TEXT and DATA_SET. If using DATA_SET, an extra field should be informed, having the name of the dataset. If the dataset doesn’t exist, it will be automatically created. Attribute entries must only have values matching the informed variables. If a value of a dataset doesn’t exist, it will be automatically created for that dataset. Check the examples below for more details. For the field &#x60;&#x60;&#x60;testScript&#x60;&#x60;&#x60;, when it is a step-by-step script: * If some step is missing in comparison to the target Test Case, it will be deleted. * Steps not having &#x60;&#x60;&#x60;id&#x60;&#x60;&#x60; will be considered as a new step and will be created. * Steps having &#x60;&#x60;&#x60;id&#x60;&#x60;&#x60; will be considered as existing steps and will be updated.
     *
     * @see #testCaseKeyPath The key of the Test Case. (required)
     * @see #body  (optional)
     */
    public static class UpdateTestCaseByTestCaseKeyOper implements Oper {

        public static final Method REQ_METHOD = PUT;
        public static final String REQ_URI = "/testcase/{testCaseKey}";
        public static final String TEST_CASE_KEY_PATH = "testCaseKey";
        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public UpdateTestCaseByTestCaseKeyOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setContentType(ContentType.JSON);
            reqSpec.setAccept(ContentType.JSON);
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * PUT /testcase/{testCaseKey}
         *
         * @param handler handler
         * @param <T>     type
         * @return type
         */
        @Override
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * @param testCase (TestCase)  (optional)
         * @return operation
         */
        public UpdateTestCaseByTestCaseKeyOper body(TestCase testCase) {
            reqSpec.setBody(testCase);
            return this;
        }

        /**
         * @param testCaseKey (String) The key of the Test Case. (required)
         * @return operation
         */
        public UpdateTestCaseByTestCaseKeyOper testCaseKeyPath(Object testCaseKey) {
            reqSpec.addPathParam(TEST_CASE_KEY_PATH, testCaseKey);
            return this;
        }

        /**
         * Customize request specification
         *
         * @param reqSpecCustomizer consumer to modify the RequestSpecBuilder
         * @return operation
         */
        public UpdateTestCaseByTestCaseKeyOper reqSpec(Consumer<RequestSpecBuilder> reqSpecCustomizer) {
            reqSpecCustomizer.accept(reqSpec);
            return this;
        }

        /**
         * Customize response specification
         *
         * @param respSpecCustomizer consumer to modify the ResponseSpecBuilder
         * @return operation
         */
        public UpdateTestCaseByTestCaseKeyOper respSpec(Consumer<ResponseSpecBuilder> respSpecCustomizer) {
            respSpecCustomizer.accept(respSpec);
            return this;
        }
    }
}
