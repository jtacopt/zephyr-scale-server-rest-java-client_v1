/*
 * Zephyr Scale Server API (v1)
 * ## DISCLAIMER  We strongly discourage and do not endorse using private APIs for any purpose. Important points to remember:  1. **Non-Endorsement**: We do not support or endorse private API usage.  2. **API Changes**: Private APIs may change without notice; use them at your own risk.  3. **Data Responsibility**: We are not responsible for issues arising from private API use, such ***as data corruption***.  Please follow our terms of service and official ***public*** APIs for a stable and secure application experience. Unauthorized private API use may lead to instability and ***data corruption***.  ## Accessing the API The Zephyr Scale REST API is ready to use if you have Zephyr Scale installed on your JIRA instance. All API uses the following base URL: ``` http://your-jira-host:port/your-jira-context/rest/atm/1.0/ ``` For instance, you can create test results using the \"testresult\" api: ``` POST http://localhost:2990/jira/rest/atm/1.0/testresult ```  ## Authentication Basics Any authentication that works with JIRA will work with the Zephyr Scale REST API. The prefered authentication methods are OAuth and HTTP Basic. See the [JIRA SERVER REST API](https://developer.atlassian.com/server/jira/platform/rest-apis) docs for details. ## Using Status and Environment Fields Some entities, such as the Test Results, may have status and environment fields. The values of these fields are identified by name, not by the localized name. Both fields may have custom values defined by the user on the Zephyr Scale configuration area. All values are **case sensitive**, and they must be set just as displayed on the add-on.  These are the default values, which must be used on the APIs instead of their localized versions: * Test Cases:   * Draft   * Approved   * Deprecated  * Test Runs:   * Not Executed   * In Progress   * Done  * Test Results:   * Not Executed   * In Progress   * Pass   * Fail   * Blocked ## Handling Date Format The API supports the ISO 8601 format for date/time fields. This allows you to pass in the level of detail you need to. When a field is not specified, the earliest possible value is the default. For example, if you do not specify a time of day, we will default to 00:00 (midnight). Similarly, not specifying a timezone defaults the timezone to GMT. The full representation is of the format: ``` yyyy-MM-ddTHH:mm:ss.SSSZ ``` This table illustrates some example valid dates and times:  | Input | Equivalent to | | ------ | ----------- | | 2016 | 2016-01-01T00:00:00.000Z | | 2016-04 | 2016-04-01T00:00:00.000Z | | 2016-04-15 | 2016-04-15T00:00:00.000Z | | 2016-04-15T16 | 2016-04-15T16:00:00.000Z | | 2016-04-15T16:15 | 2016-04-15T16:15:00.000Z | | 2016-04-15T16:15Z | 2016-04-15T16:15:00.000Z (GMT time zone) | | 2016-04-15T16:15-0300 | 2016-04-15T16:15:00.000-0300 (Brazil time zone) |
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.pt.taco.jira.zephyr.client;

import com.google.gson.reflect.TypeToken;
import com.pt.taco.jira.zephyr.client.model.Attachment;
import io.restassured.RestAssured;
import io.restassured.builder.RequestSpecBuilder;
import io.restassured.builder.ResponseSpecBuilder;
import io.restassured.http.ContentType;
import io.restassured.http.Method;
import io.restassured.response.Response;

import java.lang.reflect.Type;
import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

import static io.restassured.http.Method.DELETE;
import static io.restassured.http.Method.GET;
import static io.restassured.http.Method.POST;
import static io.restassured.http.Method.PUT;

public class TestPlanApi {

    private final Supplier<RequestSpecBuilder> reqSpecSupplier;
    private Consumer<RequestSpecBuilder> reqSpecCustomizer;

    private TestPlanApi(Supplier<RequestSpecBuilder> reqSpecSupplier) {
        this.reqSpecSupplier = reqSpecSupplier;
    }

    public static TestPlanApi testPlan(Supplier<RequestSpecBuilder> reqSpecSupplier) {
        return new TestPlanApi(reqSpecSupplier);
    }

    private RequestSpecBuilder createReqSpec() {
        RequestSpecBuilder reqSpec = reqSpecSupplier.get();
        if (reqSpecCustomizer != null) {
            reqSpecCustomizer.accept(reqSpec);
        }
        return reqSpec;
    }

    public List<Oper> getAllOperations() {
        return Arrays.asList(
                createTestPlan(),
                createTestPlanAttachmentsByTestPlanKey(),
                deleteTestPlanByTestPlanKey(),
                findTestPlan(),
                getTestPlanAttachmentsByTestPlanKey(),
                getTestPlanByTestPlanKey(),
                updateTestPlanByTestPlanKey()
        );
    }

    public CreateTestPlanOper createTestPlan() {
        return new CreateTestPlanOper(createReqSpec());
    }

    public CreateTestPlanAttachmentsByTestPlanKeyOper createTestPlanAttachmentsByTestPlanKey() {
        return new CreateTestPlanAttachmentsByTestPlanKeyOper(createReqSpec());
    }

    public DeleteTestPlanByTestPlanKeyOper deleteTestPlanByTestPlanKey() {
        return new DeleteTestPlanByTestPlanKeyOper(createReqSpec());
    }

    public FindTestPlanOper findTestPlan() {
        return new FindTestPlanOper(createReqSpec());
    }

    public GetTestPlanAttachmentsByTestPlanKeyOper getTestPlanAttachmentsByTestPlanKey() {
        return new GetTestPlanAttachmentsByTestPlanKeyOper(createReqSpec());
    }

    public GetTestPlanByTestPlanKeyOper getTestPlanByTestPlanKey() {
        return new GetTestPlanByTestPlanKeyOper(createReqSpec());
    }

    public UpdateTestPlanByTestPlanKeyOper updateTestPlanByTestPlanKey() {
        return new UpdateTestPlanByTestPlanKeyOper(createReqSpec());
    }

    /**
     * Customize request specification
     *
     * @param reqSpecCustomizer consumer to modify the RequestSpecBuilder
     * @return api
     */
    public TestPlanApi reqSpec(Consumer<RequestSpecBuilder> reqSpecCustomizer) {
        this.reqSpecCustomizer = reqSpecCustomizer;
        return this;
    }

    /**
     * Creates a new Test Plan.  Whitespace is not allowed for labels, and it will be replaced by an underscore character. The optional field &#x60;&#x60;&#x60;folder&#x60;&#x60;&#x60;, if defined, must contain an existent folder name. No folder will be created. The field &#x60;&#x60;&#x60;status&#x60;&#x60;&#x60; will be set to a default value if not defined.
     *
     * @see #body  (optional)
     * return Object
     */
    public static class CreateTestPlanOper implements Oper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/rest/atm/1.0/testplan";

        private final RequestSpecBuilder reqSpec;
        private final ResponseSpecBuilder respSpec;

        public CreateTestPlanOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setContentType(ContentType.JSON);
            reqSpec.setAccept(ContentType.JSON);
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /testplan
         *
         * @param handler handler
         * @param <T>     type
         * @return type
         */
        @Override
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /testplan
         *
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>() {
            }.getType();
            return execute(handler).as(type);
        }

        /**
         * @param body (String)  (optional)
         * @return operation
         */
        public CreateTestPlanOper body(String body) {
            reqSpec.setBody(body);
            return this;
        }

        /**
         * Customize request specification
         *
         * @param reqSpecCustomizer consumer to modify the RequestSpecBuilder
         * @return operation
         */
        public CreateTestPlanOper reqSpec(Consumer<RequestSpecBuilder> reqSpecCustomizer) {
            reqSpecCustomizer.accept(reqSpec);
            return this;
        }

        /**
         * Customize response specification
         *
         * @param respSpecCustomizer consumer to modify the ResponseSpecBuilder
         * @return operation
         */
        public CreateTestPlanOper respSpec(Consumer<ResponseSpecBuilder> respSpecCustomizer) {
            respSpecCustomizer.accept(respSpec);
            return this;
        }
    }

    /**
     * Create a new attachment on the specified Test Plan.
     *
     * @see #testPlanKeyPath The key of the Test Plan. (required)
     * return Object
     */
    public static class CreateTestPlanAttachmentsByTestPlanKeyOper implements Oper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/rest/atm/1.0/testplan/{testPlanKey}/attachments";
        public static final String TEST_PLAN_KEY_PATH = "testPlanKey";
        private final RequestSpecBuilder reqSpec;
        private final ResponseSpecBuilder respSpec;

        public CreateTestPlanAttachmentsByTestPlanKeyOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setContentType("multipart/form-data");
            reqSpec.setAccept(ContentType.JSON);
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /testplan/{testPlanKey}/attachments
         *
         * @param handler handler
         * @param <T>     type
         * @return type
         */
        @Override
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /testplan/{testPlanKey}/attachments
         *
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>() {
            }.getType();
            return execute(handler).as(type);
        }

        /**
         * @param testPlanKey (String) The key of the Test Plan. (required)
         * @return operation
         */
        public CreateTestPlanAttachmentsByTestPlanKeyOper testPlanKeyPath(Object testPlanKey) {
            reqSpec.addPathParam(TEST_PLAN_KEY_PATH, testPlanKey);
            return this;
        }

        /**
         * Customize request specification
         *
         * @param reqSpecCustomizer consumer to modify the RequestSpecBuilder
         * @return operation
         */
        public CreateTestPlanAttachmentsByTestPlanKeyOper reqSpec(Consumer<RequestSpecBuilder> reqSpecCustomizer) {
            reqSpecCustomizer.accept(reqSpec);
            return this;
        }

        /**
         * Customize response specification
         *
         * @param respSpecCustomizer consumer to modify the ResponseSpecBuilder
         * @return operation
         */
        public CreateTestPlanAttachmentsByTestPlanKeyOper respSpec(Consumer<ResponseSpecBuilder> respSpecCustomizer) {
            respSpecCustomizer.accept(respSpec);
            return this;
        }
    }

    /**
     * Delete the Test Plan matching the given key.
     *
     * @see #testPlanKeyPath The key of the Test Plan. (required)
     */
    public static class DeleteTestPlanByTestPlanKeyOper implements Oper {

        public static final Method REQ_METHOD = DELETE;
        public static final String REQ_URI = "/rest/atm/1.0/testplan/{testPlanKey}";
        public static final String TEST_PLAN_KEY_PATH = "testPlanKey";
        private final RequestSpecBuilder reqSpec;
        private final ResponseSpecBuilder respSpec;

        public DeleteTestPlanByTestPlanKeyOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept(ContentType.JSON);
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * DELETE /testplan/{testPlanKey}
         *
         * @param handler handler
         * @param <T>     type
         * @return type
         */
        @Override
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * @param testPlanKey (String) The key of the Test Plan. (required)
         * @return operation
         */
        public DeleteTestPlanByTestPlanKeyOper testPlanKeyPath(Object testPlanKey) {
            reqSpec.addPathParam(TEST_PLAN_KEY_PATH, testPlanKey);
            return this;
        }

        /**
         * Customize request specification
         *
         * @param reqSpecCustomizer consumer to modify the RequestSpecBuilder
         * @return operation
         */
        public DeleteTestPlanByTestPlanKeyOper reqSpec(Consumer<RequestSpecBuilder> reqSpecCustomizer) {
            reqSpecCustomizer.accept(reqSpec);
            return this;
        }

        /**
         * Customize response specification
         *
         * @param respSpecCustomizer consumer to modify the ResponseSpecBuilder
         * @return operation
         */
        public DeleteTestPlanByTestPlanKeyOper respSpec(Consumer<ResponseSpecBuilder> respSpecCustomizer) {
            respSpecCustomizer.accept(respSpec);
            return this;
        }
    }

    /**
     * Retrieve the Test Plans that matches the query passed as parameter.
     *
     * @see #fieldsQuery The fields of the Test Plan to be included on the response. If not set, all fields will be returned. Inexistent fields will be ignored. (optional)
     * @see #queryQuery A query to filter Test Plans. The query syntax is similar to the JIRA JQL.  * Available fields: &#x60;&#x60;&#x60;projectKey&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;key&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;name&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;status&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;folder&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;labels&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;owner&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;issueKeys&#x60;&#x60;&#x60; and custom fields. When filtering by custom fields, the field name must be quoted. * Available operators: &#x60;&#x60;&#x60;&#x3D;&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;&gt;&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;&gt;&#x3D;&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;&lt;&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;&lt;&#x3D;&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;IN&#x60;&#x60;&#x60; * For Single and Multi Choice custom fields, operator \&quot;&#x3D;\&quot; is not supported, use \&quot;IN\&quot; instead * Available logical operators: &#x60;&#x60;&#x60;AND&#x60;&#x60;&#x60;  It is always a good idea considering using the &#x60;&#x60;&#x60;projectKey&#x60;&#x60;&#x60; field to match values that only belongs to that project, such as statuses, folders, etc.  Folders always have to start with a \&quot;/\&quot;, for instance: \&quot;/a folder\&quot;. The \&quot;/\&quot; matches the root, above all folders.  The query syntax is very strict. The use of whitespaces between fields, operators and logical operators is required, as well as the use of double quotes for string values.  Usage examples: * projectKey &#x3D; \&quot;JQA\&quot; AND status &#x3D; \&quot;Draft\&quot; * projectKey &#x3D; \&quot;JQA\&quot; AND status IN (\&quot;Draft\&quot;, \&quot;Deprecated\&quot;) AND labels IN (\&quot;Functional\&quot;, \&quot;UI\&quot;) * projectKey &#x3D; \&quot;JQA\&quot; AND status &#x3D; \&quot;Draft\&quot; AND folder &#x3D; \&quot;/\&quot; * projectKey &#x3D; \&quot;JQA\&quot; AND folder &#x3D; \&quot;/folder with some test plans\&quot; * projectKey &#x3D; \&quot;JQA\&quot; AND folder &#x3D; \&quot;/folder with some test plans/child folder\&quot; * projectKey &#x3D; \&quot;JQA\&quot; AND folder IN (\&quot;/parent folder\&quot;, \&quot;/parent folder/child folder\&quot;) * projectKey &#x3D; \&quot;JQA\&quot; AND \&quot;My Custom Field\&quot; &#x3D; \&quot;Some value\&quot; * projectKey &#x3D; \&quot;JQA\&quot; AND \&quot;Single Choice Custom Field\&quot; IN (\&quot;Some value\&quot;) * projectKey &#x3D; \&quot;JQA\&quot; AND \&quot;Multi Choice Custom Field\&quot; IN (\&quot;Some value\&quot;, \&quot;Another value\&quot;) * projectKey &#x3D; \&quot;JQA\&quot; AND issueKeys IN (\&quot;JQA-5\&quot;, \&quot;JQA-4\&quot;)  (optional)
     * @see #startAtQuery An offset to use with the query. This can be useful when paginating results. (optional)
     * @see #maxResultsQuery The max result count, limiting the query results. If not provided, the default value of 200 will be used. (optional)
     * return Object
     */
    public static class FindTestPlanOper implements Oper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/rest/atm/1.0/testplan/search";
        public static final String FIELDS_QUERY = "fields";
        public static final String QUERY_QUERY = "query";
        public static final String START_AT_QUERY = "startAt";
        public static final String MAX_RESULTS_QUERY = "maxResults";
        private final RequestSpecBuilder reqSpec;
        private final ResponseSpecBuilder respSpec;

        public FindTestPlanOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept(ContentType.JSON);
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /testplan/search
         *
         * @param handler handler
         * @param <T>     type
         * @return type
         */
        @Override
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /testplan/search
         *
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>() {
            }.getType();
            return execute(handler).as(type);
        }

        /**
         * @param fields (String) The fields of the Test Plan to be included on the response. If not set, all fields will be returned. Inexistent fields will be ignored. (optional)
         * @return operation
         */
        public FindTestPlanOper fieldsQuery(Object... fields) {
            reqSpec.addQueryParam(FIELDS_QUERY, fields);
            return this;
        }

        /**
         * @param query (String) A query to filter Test Plans. The query syntax is similar to the JIRA JQL.  * Available fields: &#x60;&#x60;&#x60;projectKey&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;key&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;name&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;status&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;folder&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;labels&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;owner&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;issueKeys&#x60;&#x60;&#x60; and custom fields. When filtering by custom fields, the field name must be quoted. * Available operators: &#x60;&#x60;&#x60;&#x3D;&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;&gt;&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;&gt;&#x3D;&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;&lt;&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;&lt;&#x3D;&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;IN&#x60;&#x60;&#x60; * For Single and Multi Choice custom fields, operator \&quot;&#x3D;\&quot; is not supported, use \&quot;IN\&quot; instead * Available logical operators: &#x60;&#x60;&#x60;AND&#x60;&#x60;&#x60;  It is always a good idea considering using the &#x60;&#x60;&#x60;projectKey&#x60;&#x60;&#x60; field to match values that only belongs to that project, such as statuses, folders, etc.  Folders always have to start with a \&quot;/\&quot;, for instance: \&quot;/a folder\&quot;. The \&quot;/\&quot; matches the root, above all folders.  The query syntax is very strict. The use of whitespaces between fields, operators and logical operators is required, as well as the use of double quotes for string values.  Usage examples: * projectKey &#x3D; \&quot;JQA\&quot; AND status &#x3D; \&quot;Draft\&quot; * projectKey &#x3D; \&quot;JQA\&quot; AND status IN (\&quot;Draft\&quot;, \&quot;Deprecated\&quot;) AND labels IN (\&quot;Functional\&quot;, \&quot;UI\&quot;) * projectKey &#x3D; \&quot;JQA\&quot; AND status &#x3D; \&quot;Draft\&quot; AND folder &#x3D; \&quot;/\&quot; * projectKey &#x3D; \&quot;JQA\&quot; AND folder &#x3D; \&quot;/folder with some test plans\&quot; * projectKey &#x3D; \&quot;JQA\&quot; AND folder &#x3D; \&quot;/folder with some test plans/child folder\&quot; * projectKey &#x3D; \&quot;JQA\&quot; AND folder IN (\&quot;/parent folder\&quot;, \&quot;/parent folder/child folder\&quot;) * projectKey &#x3D; \&quot;JQA\&quot; AND \&quot;My Custom Field\&quot; &#x3D; \&quot;Some value\&quot; * projectKey &#x3D; \&quot;JQA\&quot; AND \&quot;Single Choice Custom Field\&quot; IN (\&quot;Some value\&quot;) * projectKey &#x3D; \&quot;JQA\&quot; AND \&quot;Multi Choice Custom Field\&quot; IN (\&quot;Some value\&quot;, \&quot;Another value\&quot;) * projectKey &#x3D; \&quot;JQA\&quot; AND issueKeys IN (\&quot;JQA-5\&quot;, \&quot;JQA-4\&quot;)  (optional)
         * @return operation
         */
        public FindTestPlanOper queryQuery(Object... query) {
            reqSpec.addQueryParam(QUERY_QUERY, query);
            return this;
        }

        /**
         * @param startAt (Integer) An offset to use with the query. This can be useful when paginating results. (optional)
         * @return operation
         */
        public FindTestPlanOper startAtQuery(Object... startAt) {
            reqSpec.addQueryParam(START_AT_QUERY, startAt);
            return this;
        }

        /**
         * @param maxResults (Integer) The max result count, limiting the query results. If not provided, the default value of 200 will be used. (optional)
         * @return operation
         */
        public FindTestPlanOper maxResultsQuery(Object... maxResults) {
            reqSpec.addQueryParam(MAX_RESULTS_QUERY, maxResults);
            return this;
        }

        /**
         * Customize request specification
         *
         * @param reqSpecCustomizer consumer to modify the RequestSpecBuilder
         * @return operation
         */
        public FindTestPlanOper reqSpec(Consumer<RequestSpecBuilder> reqSpecCustomizer) {
            reqSpecCustomizer.accept(reqSpec);
            return this;
        }

        /**
         * Customize response specification
         *
         * @param respSpecCustomizer consumer to modify the ResponseSpecBuilder
         * @return operation
         */
        public FindTestPlanOper respSpec(Consumer<ResponseSpecBuilder> respSpecCustomizer) {
            respSpecCustomizer.accept(respSpec);
            return this;
        }
    }

    /**
     * Retrieve the Test Plan Attachments matching the given key.
     *
     * @see #testPlanKeyPath The key of the Test Plan. (required)
     * return List&lt;Attachment&gt;
     */
    public static class GetTestPlanAttachmentsByTestPlanKeyOper implements Oper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/rest/atm/1.0/testplan/{testPlanKey}/attachments";
        public static final String TEST_PLAN_KEY_PATH = "testPlanKey";
        private final RequestSpecBuilder reqSpec;
        private final ResponseSpecBuilder respSpec;

        public GetTestPlanAttachmentsByTestPlanKeyOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept(ContentType.JSON);
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /testplan/{testPlanKey}/attachments
         *
         * @param handler handler
         * @param <T>     type
         * @return type
         */
        @Override
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /testplan/{testPlanKey}/attachments
         *
         * @param handler handler
         * @return List&lt;Attachment&gt;
         */
        public List<Attachment> executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<List<Attachment>>() {
            }.getType();
            return execute(handler).as(type);
        }

        /**
         * @param testPlanKey (String) The key of the Test Plan. (required)
         * @return operation
         */
        public GetTestPlanAttachmentsByTestPlanKeyOper testPlanKeyPath(Object testPlanKey) {
            reqSpec.addPathParam(TEST_PLAN_KEY_PATH, testPlanKey);
            return this;
        }

        /**
         * Customize request specification
         *
         * @param reqSpecCustomizer consumer to modify the RequestSpecBuilder
         * @return operation
         */
        public GetTestPlanAttachmentsByTestPlanKeyOper reqSpec(Consumer<RequestSpecBuilder> reqSpecCustomizer) {
            reqSpecCustomizer.accept(reqSpec);
            return this;
        }

        /**
         * Customize response specification
         *
         * @param respSpecCustomizer consumer to modify the ResponseSpecBuilder
         * @return operation
         */
        public GetTestPlanAttachmentsByTestPlanKeyOper respSpec(Consumer<ResponseSpecBuilder> respSpecCustomizer) {
            respSpecCustomizer.accept(respSpec);
            return this;
        }
    }

    /**
     * Retrieve the Test Plan matching the given key.
     *
     * @see #testPlanKeyPath The key of the Test Plan. (required)
     * @see #fieldsQuery The fields of the Test Plan to be included on the response. If not set, all fields will be returned. Inexistent fields will be ignored. (optional)
     * return Object
     */
    public static class GetTestPlanByTestPlanKeyOper implements Oper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/rest/atm/1.0/testplan/{testPlanKey}";
        public static final String TEST_PLAN_KEY_PATH = "testPlanKey";
        public static final String FIELDS_QUERY = "fields";
        private final RequestSpecBuilder reqSpec;
        private final ResponseSpecBuilder respSpec;

        public GetTestPlanByTestPlanKeyOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept(ContentType.JSON);
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /testplan/{testPlanKey}
         *
         * @param handler handler
         * @param <T>     type
         * @return type
         */
        @Override
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /testplan/{testPlanKey}
         *
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>() {
            }.getType();
            return execute(handler).as(type);
        }

        /**
         * @param testPlanKey (String) The key of the Test Plan. (required)
         * @return operation
         */
        public GetTestPlanByTestPlanKeyOper testPlanKeyPath(Object testPlanKey) {
            reqSpec.addPathParam(TEST_PLAN_KEY_PATH, testPlanKey);
            return this;
        }

        /**
         * @param fields (String) The fields of the Test Plan to be included on the response. If not set, all fields will be returned. Inexistent fields will be ignored. (optional)
         * @return operation
         */
        public GetTestPlanByTestPlanKeyOper fieldsQuery(Object... fields) {
            reqSpec.addQueryParam(FIELDS_QUERY, fields);
            return this;
        }

        /**
         * Customize request specification
         *
         * @param reqSpecCustomizer consumer to modify the RequestSpecBuilder
         * @return operation
         */
        public GetTestPlanByTestPlanKeyOper reqSpec(Consumer<RequestSpecBuilder> reqSpecCustomizer) {
            reqSpecCustomizer.accept(reqSpec);
            return this;
        }

        /**
         * Customize response specification
         *
         * @param respSpecCustomizer consumer to modify the ResponseSpecBuilder
         * @return operation
         */
        public GetTestPlanByTestPlanKeyOper respSpec(Consumer<ResponseSpecBuilder> respSpecCustomizer) {
            respSpecCustomizer.accept(respSpec);
            return this;
        }
    }

    /**
     * Updates a Test Plan.  Whitespace is not allowed for labels, and it will be replaced by an underscore character. The optional field &#x60;&#x60;&#x60;folder&#x60;&#x60;&#x60;, if defined, must contain an existent folder name. No folder will be created. The field &#x60;&#x60;&#x60;status&#x60;&#x60;&#x60; will be set to a default value if not defined.
     *
     * @see #testPlanKeyPath The key of the Test Plan. (required)
     * @see #body  (optional)
     */
    public static class UpdateTestPlanByTestPlanKeyOper implements Oper {

        public static final Method REQ_METHOD = PUT;
        public static final String REQ_URI = "/rest/atm/1.0/testplan/{testPlanKey}";
        public static final String TEST_PLAN_KEY_PATH = "testPlanKey";
        private final RequestSpecBuilder reqSpec;
        private final ResponseSpecBuilder respSpec;

        public UpdateTestPlanByTestPlanKeyOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setContentType(ContentType.JSON);
            reqSpec.setAccept(ContentType.JSON);
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * PUT /testplan/{testPlanKey}
         *
         * @param handler handler
         * @param <T>     type
         * @return type
         */
        @Override
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * @param body (String)  (optional)
         * @return operation
         */
        public UpdateTestPlanByTestPlanKeyOper body(String body) {
            reqSpec.setBody(body);
            return this;
        }

        /**
         * @param testPlanKey (String) The key of the Test Plan. (required)
         * @return operation
         */
        public UpdateTestPlanByTestPlanKeyOper testPlanKeyPath(Object testPlanKey) {
            reqSpec.addPathParam(TEST_PLAN_KEY_PATH, testPlanKey);
            return this;
        }

        /**
         * Customize request specification
         *
         * @param reqSpecCustomizer consumer to modify the RequestSpecBuilder
         * @return operation
         */
        public UpdateTestPlanByTestPlanKeyOper reqSpec(Consumer<RequestSpecBuilder> reqSpecCustomizer) {
            reqSpecCustomizer.accept(reqSpec);
            return this;
        }

        /**
         * Customize response specification
         *
         * @param respSpecCustomizer consumer to modify the ResponseSpecBuilder
         * @return operation
         */
        public UpdateTestPlanByTestPlanKeyOper respSpec(Consumer<ResponseSpecBuilder> respSpecCustomizer) {
            respSpecCustomizer.accept(respSpec);
            return this;
        }
    }
}
